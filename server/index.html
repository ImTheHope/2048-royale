<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2048 Royale</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;700;800;900&family=JetBrains+Mono:wght@600;700;800&display=swap" rel="stylesheet">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        :root{
            --bg:#08080d;--bg2:#0e0e16;--card:#13131a;--border:#1e1e2a;
            --text:#e8e8f0;--dim:#5a5a70;--accent:#f7b731;
            --accent-glow:rgba(247,183,49,.3);--danger:#fc5c65;--success:#26de81;
            --p1:#f7b731;--p2:#6c5ce7;
        }
        body{background:var(--bg);color:var(--text);font-family:'Outfit',sans-serif;
            min-height:100vh;display:flex;flex-direction:column;align-items:center;overflow-x:hidden}
        body::before{content:'';position:fixed;inset:0;
            background-image:linear-gradient(rgba(255,255,255,.015) 1px,transparent 1px),
            linear-gradient(90deg,rgba(255,255,255,.015) 1px,transparent 1px);
            background-size:50px 50px;pointer-events:none;z-index:0}

        /* ‚îÄ‚îÄ‚îÄ MENU ‚îÄ‚îÄ‚îÄ */
        #menuScreen{position:relative;z-index:2;display:flex;flex-direction:column;
            align-items:center;justify-content:center;min-height:100vh;gap:32px;padding:20px}
        .menu-title{font-size:4rem;font-weight:900;letter-spacing:-2px;
            background:linear-gradient(135deg,var(--accent),#ff6b6b,var(--accent));
            background-size:200% 200%;animation:gradShift 3s ease infinite;
            -webkit-background-clip:text;-webkit-text-fill-color:transparent;line-height:1}
        @keyframes gradShift{0%,100%{background-position:0% 50%}50%{background-position:100% 50%}}
        .menu-sub{font-size:.8rem;font-weight:600;text-transform:uppercase;
            letter-spacing:6px;color:var(--dim);margin-top:-8px}
        .menu-modes{display:flex;gap:16px;flex-wrap:wrap;justify-content:center}
        .mode-card{background:var(--card);border:1px solid var(--border);border-radius:16px;
            padding:28px 24px;width:220px;cursor:pointer;transition:all .25s ease;
            display:flex;flex-direction:column;align-items:center;gap:10px;text-align:center}
        .mode-card:hover{border-color:var(--accent);transform:translateY(-4px);
            box-shadow:0 8px 32px rgba(247,183,49,.12)}
        .mode-icon{font-size:2.4rem}
        .mode-name{font-size:1.1rem;font-weight:800;letter-spacing:.5px}
        .mode-desc{font-size:.75rem;color:var(--dim);line-height:1.5}
        .mode-card.online{opacity:.5;pointer-events:auto}
        .mode-card.online .mode-desc::after{content:" (n√©cessite le serveur Go)";color:var(--danger)}

        /* ‚îÄ‚îÄ‚îÄ GAME SCREEN ‚îÄ‚îÄ‚îÄ */
        #gameScreen{display:none;position:relative;z-index:2;width:100%;
            flex-direction:column;align-items:center;padding:12px;gap:12px}
        #gameScreen.active{display:flex}
        #menuScreen.hidden{display:none}

        .top-bar{width:100%;max-width:960px;display:flex;justify-content:space-between;align-items:center}
        .top-left{display:flex;align-items:center;gap:16px}
        .logo-sm h1{font-size:1.6rem;font-weight:900;letter-spacing:-1px;
            background:linear-gradient(135deg,var(--accent),#ff6b6b);
            -webkit-background-clip:text;-webkit-text-fill-color:transparent;line-height:1}
        .logo-sm span{font-size:.55rem;font-weight:600;text-transform:uppercase;
            letter-spacing:3px;color:var(--dim)}
        .btn{font-family:'Outfit',sans-serif;font-weight:700;font-size:.75rem;
            letter-spacing:1px;text-transform:uppercase;padding:8px 18px;border:none;
            border-radius:8px;cursor:pointer;transition:all .2s ease}
        .btn-back{background:var(--card);color:var(--dim);border:1px solid var(--border)}
        .btn-back:hover{border-color:var(--dim);color:var(--text)}
        .btn-accent{background:var(--accent);color:var(--bg)}
        .btn-accent:hover{transform:translateY(-1px);box-shadow:0 4px 16px var(--accent-glow)}

        /* ‚îÄ‚îÄ‚îÄ ARENA ‚îÄ‚îÄ‚îÄ */
        .arena{display:flex;gap:20px;flex-wrap:wrap;justify-content:center;width:100%;max-width:960px}
        .player-zone{display:flex;flex-direction:column;align-items:center;gap:10px;flex:1;min-width:300px;max-width:480px}
        .player-header{display:flex;justify-content:space-between;align-items:center;width:100%;padding:0 4px}
        .player-name{font-size:.8rem;font-weight:700;text-transform:uppercase;letter-spacing:2px}
        .player-name.p1{color:var(--p1)}.player-name.p2{color:var(--p2)}
        .player-score{font-family:'JetBrains Mono',monospace;font-size:1.1rem;font-weight:700;color:var(--accent)}
        .game-wrapper{position:relative;width:100%;aspect-ratio:1;border-radius:14px;
            overflow:hidden;border:1px solid var(--border);
            box-shadow:0 0 30px rgba(0,0,0,.4)}
        .game-wrapper.winner{border-color:var(--success);box-shadow:0 0 30px rgba(38,222,129,.2)}
        .game-wrapper.loser{opacity:.5}
        canvas{width:100%;height:100%;display:block;touch-action:none}

        .player-controls{font-size:.65rem;color:var(--dim);font-weight:600;
            text-transform:uppercase;letter-spacing:1px}
        .player-controls kbd{display:inline-block;background:var(--card);border:1px solid var(--border);
            border-radius:5px;padding:2px 6px;font-family:'JetBrains Mono',monospace;font-size:.6rem;margin:0 1px}

        /* ‚îÄ‚îÄ‚îÄ OVERLAYS ‚îÄ‚îÄ‚îÄ */
        .overlay{position:absolute;inset:0;background:rgba(8,8,13,.88);backdrop-filter:blur(6px);
            display:flex;flex-direction:column;align-items:center;justify-content:center;
            gap:12px;opacity:0;pointer-events:none;transition:opacity .4s ease;border-radius:14px;z-index:5}
        .overlay.active{opacity:1;pointer-events:all}
        .overlay h2{font-size:2rem;font-weight:900}
        .overlay h2.win{background:linear-gradient(135deg,var(--accent),#ff6b6b);
            -webkit-background-clip:text;-webkit-text-fill-color:transparent}
        .overlay h2.lose{color:var(--danger)}
        .overlay .sub{font-family:'JetBrains Mono',monospace;font-size:1rem;color:var(--dim)}

        /* ‚îÄ‚îÄ‚îÄ COUNTDOWN ‚îÄ‚îÄ‚îÄ */
        .countdown{position:fixed;inset:0;z-index:100;display:flex;align-items:center;
            justify-content:center;background:rgba(8,8,13,.92);backdrop-filter:blur(10px)}
        .countdown.hidden{display:none}
        .countdown-num{font-size:8rem;font-weight:900;color:var(--accent);
            animation:countPulse .8s ease infinite}
        @keyframes countPulse{0%,100%{transform:scale(1);opacity:1}50%{transform:scale(1.2);opacity:.7}}

        /* ‚îÄ‚îÄ‚îÄ RESULT BANNER ‚îÄ‚îÄ‚îÄ */
        .result-banner{display:none;width:100%;max-width:960px;padding:16px 24px;
            border-radius:12px;text-align:center;font-weight:800;font-size:1.1rem;gap:12px;
            flex-direction:column;align-items:center}
        .result-banner.active{display:flex}
        .result-banner.p1-wins{background:linear-gradient(135deg,rgba(247,183,49,.15),rgba(247,183,49,.05));
            border:1px solid rgba(247,183,49,.3);color:var(--p1)}
        .result-banner.p2-wins{background:linear-gradient(135deg,rgba(108,92,231,.15),rgba(108,92,231,.05));
            border:1px solid rgba(108,92,231,.3);color:var(--p2)}
        .result-banner.solo-over{background:linear-gradient(135deg,rgba(252,92,101,.15),rgba(252,92,101,.05));
            border:1px solid rgba(252,92,101,.3);color:var(--danger)}
        .result-banner.solo-win{background:linear-gradient(135deg,rgba(38,222,129,.15),rgba(38,222,129,.05));
            border:1px solid rgba(38,222,129,.3);color:var(--success)}

        /* ‚îÄ‚îÄ‚îÄ ONLINE MODAL ‚îÄ‚îÄ‚îÄ */
        .modal-overlay{position:fixed;inset:0;z-index:50;background:rgba(8,8,13,.9);
            backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center}
        .modal-overlay.hidden{display:none}
        .modal{background:var(--card);border:1px solid var(--border);border-radius:16px;
            padding:32px;max-width:380px;width:90%;display:flex;flex-direction:column;gap:16px;align-items:center}
        .modal h3{font-size:1.2rem;font-weight:800}
        .modal input{width:100%;padding:10px 14px;border-radius:8px;border:1px solid var(--border);
            background:var(--bg2);color:var(--text);font-family:'JetBrains Mono',monospace;
            font-size:1rem;text-align:center;letter-spacing:4px;outline:none}
        .modal input:focus{border-color:var(--accent)}
        .modal input::placeholder{letter-spacing:1px;color:var(--dim)}
        .modal-btns{display:flex;gap:10px;width:100%}
        .modal-btns .btn{flex:1}
        .modal .status{font-size:.8rem;color:var(--dim)}
        .modal .error{font-size:.8rem;color:var(--danger)}

        @media(max-width:680px){
            .arena{flex-direction:column;align-items:center}
            .player-zone{max-width:360px;min-width:unset}
            .player-controls{display:none}
        }

        @keyframes scorePop{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
        .score-pop{animation:scorePop .2s ease}
    </style>
</head>
<body>

<!-- ‚ïê‚ïê‚ïê MENU ‚ïê‚ïê‚ïê -->
<div id="menuScreen">
    <div class="menu-title">2048</div>
    <div class="menu-sub">Royale</div>
    <div class="menu-modes">
        <div class="mode-card" onclick="startGame('solo')">
            <div class="mode-icon">üéØ</div>
            <div class="mode-name">Solo</div>
            <div class="mode-desc">Mode classique, bats ton record</div>
        </div>
        <div class="mode-card" onclick="startGame('local')">
            <div class="mode-icon">‚öîÔ∏è</div>
            <div class="mode-name">1v1 Local</div>
            <div class="mode-desc">2 joueurs, m√™me √©cran, premier √† 2048</div>
        </div>
        <div class="mode-card online" onclick="startGame('online')">
            <div class="mode-icon">üåê</div>
            <div class="mode-name">En ligne</div>
            <div class="mode-desc">Affronte un ami via WebSocket</div>
        </div>
    </div>
</div>

<!-- ‚ïê‚ïê‚ïê GAME ‚ïê‚ïê‚ïê -->
<div id="gameScreen">
    <div class="top-bar">
        <div class="top-left">
            <div class="logo-sm"><h1>2048</h1><span>Royale</span></div>
        </div>
        <div style="display:flex;gap:8px">
            <button class="btn btn-back" onclick="restartMatch()">‚Üª Restart</button>
            <button class="btn btn-back" onclick="backToMenu()">‚Üê Menu</button>
        </div>
    </div>

    <div class="result-banner" id="resultBanner">
        <span id="resultText"></span>
        <button class="btn btn-accent" onclick="restartMatch()">Rejouer</button>
    </div>

    <div class="arena" id="arena"></div>
</div>

<!-- ‚ïê‚ïê‚ïê COUNTDOWN ‚ïê‚ïê‚ïê -->
<div class="countdown hidden" id="countdown">
    <div class="countdown-num" id="countdownNum">3</div>
</div>

<!-- ‚ïê‚ïê‚ïê ONLINE MODAL ‚ïê‚ïê‚ïê -->
<div class="modal-overlay hidden" id="onlineModal">
    <div class="modal">
        <h3>üåê Multijoueur en ligne</h3>
        <div class="status" id="wsStatus">Connexion...</div>
        <input id="roomInput" placeholder="Code room" maxlength="6">
        <div class="modal-btns">
            <button class="btn btn-accent" onclick="createRoom()">Cr√©er</button>
            <button class="btn btn-back" onclick="joinRoom()">Rejoindre</button>
        </div>
        <div class="error" id="wsError"></div>
        <button class="btn btn-back" style="width:100%" onclick="closeOnlineModal()">Annuler</button>
    </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TILE STYLES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const TS = {
    0:{bg:'#1a1a24',fg:'#1a1a24',fs:1},
    2:{bg:'#2a2a3a',fg:'#e8e8f0',fs:1},
    4:{bg:'#3a3a4f',fg:'#e8e8f0',fs:1},
    8:{bg:'#f7b731',fg:'#0a0a0f',fs:1},
    16:{bg:'#f7a031',fg:'#0a0a0f',fs:1},
    32:{bg:'#fc5c65',fg:'#fff',fs:1},
    64:{bg:'#e74c3c',fg:'#fff',fs:1},
    128:{bg:'#f7d731',fg:'#0a0a0f',fs:.82},
    256:{bg:'#f7cf31',fg:'#0a0a0f',fs:.82},
    512:{bg:'#f7c731',fg:'#0a0a0f',fs:.82},
    1024:{bg:'#f7bf31',fg:'#0a0a0f',fs:.68},
    2048:{bg:'#26de81',fg:'#0a0a0f',fs:.68},
    4096:{bg:'#a55eea',fg:'#fff',fs:.68},
    8192:{bg:'#8854d0',fg:'#fff',fs:.68},
};
function ts(v){return TS[v]||{bg:'#6c5ce7',fg:'#fff',fs:.55}}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TILE OBJECT (tracks identity + animation)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let globalTileId = 0;
class Tile {
    constructor(r, c, value) {
        this.id = ++globalTileId;
        this.value = value;
        this.row = r;
        this.col = c;
        // Animation state
        this.fromRow = r;
        this.fromCol = c;
        this.scale = 0;       // 0‚Üí1 for spawn
        this.mergeScale = 1;   // pop on merge
        this.animProgress = 1; // 0‚Üí1 for slide
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GAME BOARD (one per player)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class GameBoard {
    constructor(canvas, scoreEl) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.scoreEl = scoreEl;
        this.tiles = [];  // flat list of Tile objects
        this.score = 0;
        this.won = false;
        this.lost = false;
        this.keepPlaying = false;
        this.locked = false; // during animations
        this.animating = false;
        this.particles = [];
        this.setupCanvas();
    }

    setupCanvas() {
        const resize = () => {
            const w = this.canvas.parentElement.clientWidth;
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = w * dpr;
            this.canvas.height = w * dpr;
            this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            this.S = w;
            this.pad = w * .035;
            this.gap = w * .022;
            this.ts = (w - this.pad * 2 - this.gap * 3) / 4;
        };
        resize();
        this._resize = resize;
        window.addEventListener('resize', resize);
    }

    destroy() {
        window.removeEventListener('resize', this._resize);
    }

    // Grid helpers
    getGrid() {
        const g = Array.from({length:4}, () => Array(4).fill(null));
        for (const t of this.tiles) g[t.row][t.col] = t;
        return g;
    }

    cellPos(r, c) {
        return {
            x: this.pad + c * (this.ts + this.gap),
            y: this.pad + r * (this.ts + this.gap)
        };
    }

    init() {
        this.tiles = [];
        this.score = 0;
        this.won = false;
        this.lost = false;
        this.keepPlaying = false;
        this.locked = false;
        this.particles = [];
        this.spawnRandom();
        this.spawnRandom();
        this.updateScore();
    }

    spawnRandom() {
        const empty = [];
        const g = this.getGrid();
        for (let r = 0; r < 4; r++)
            for (let c = 0; c < 4; c++)
                if (!g[r][c]) empty.push({r, c});
        if (!empty.length) return;
        const {r, c} = empty[Math.floor(Math.random() * empty.length)];
        const t = new Tile(r, c, Math.random() < .9 ? 2 : 4);
        t.scale = 0; // will animate to 1
        this.tiles.push(t);
    }

    updateScore() {
        if (this.scoreEl) this.scoreEl.textContent = this.score;
    }

    // ‚îÄ‚îÄ‚îÄ MOVE WITH ANIMATION TRACKING ‚îÄ‚îÄ‚îÄ
    move(dir) {
        if (this.locked || this.lost) return false;

        const g = this.getGrid();
        let moved = false;
        let mergePoints = 0;
        const mergedTiles = new Set();

        // Work in a normalized "left" direction
        const coords = this._getTraversalOrder(dir);

        // Track merges this turn to prevent double-merge
        const alreadyMerged = new Set();

        for (const {r, c} of coords) {
            const tile = g[r][c];
            if (!tile) continue;

            let {nr, nc} = this._findFarthest(g, r, c, dir);

            // Check if we can merge with the next tile
            const {nr: mr, nc: mc} = this._nextCell(nr, nc, dir);
            const target = (mr >= 0 && mr < 4 && mc >= 0 && mc < 4) ? g[mr][mc] : null;

            if (target && target.value === tile.value && !alreadyMerged.has(target.id)) {
                // Merge!
                tile.fromRow = tile.row;
                tile.fromCol = tile.col;
                tile.row = mr;
                tile.col = mc;
                tile.value *= 2;
                tile.animProgress = 0;
                tile.mergeScale = 1.2; // will animate down

                mergePoints += tile.value;
                mergedTiles.add(target.id);
                alreadyMerged.add(tile.id);

                // Remove target from grid
                g[mr][mc] = tile;
                g[r][c] = null;
                moved = true;
            } else if (nr !== r || nc !== c) {
                // Slide
                tile.fromRow = tile.row;
                tile.fromCol = tile.col;
                tile.row = nr;
                tile.col = nc;
                tile.animProgress = 0;

                g[nr][nc] = tile;
                g[r][c] = null;
                moved = true;
            }
        }

        if (!moved) return false;

        // Remove merged tiles
        this.tiles = this.tiles.filter(t => !mergedTiles.has(t.id));

        this.score += mergePoints;
        this.updateScore();

        if (mergePoints > 0) {
            this.particles.push({
                x: this.S / 2, y: this.S / 2,
                text: '+' + mergePoints,
                opacity: 1, vy: -2.5, life: 50
            });
        }

        // Animate then spawn
        this.locked = true;
        this.animating = true;

        return true;
    }

    finishMove() {
        // Reset animation states
        for (const t of this.tiles) {
            t.animProgress = 1;
            t.mergeScale = 1;
        }

        this.spawnRandom();
        this.locked = false;
        this.animating = false;

        // Check win/lose
        if (!this.won && !this.keepPlaying) {
            for (const t of this.tiles) {
                if (t.value === 2048) {
                    this.won = true;
                    return 'win';
                }
            }
        }

        if (this._isGameOver()) {
            this.lost = true;
            return 'lose';
        }

        return null;
    }

    _getTraversalOrder(dir) {
        const order = [];
        for (let r = 0; r < 4; r++)
            for (let c = 0; c < 4; c++)
                order.push({r, c});

        // Process tiles farthest in move direction first
        if (dir === 'right') order.sort((a, b) => b.c - a.c);
        if (dir === 'left') order.sort((a, b) => a.c - b.c);
        if (dir === 'down') order.sort((a, b) => b.r - a.r);
        if (dir === 'up') order.sort((a, b) => a.r - b.r);
        return order;
    }

    _findFarthest(g, r, c, dir) {
        const dr = dir === 'down' ? 1 : dir === 'up' ? -1 : 0;
        const dc = dir === 'right' ? 1 : dir === 'left' ? -1 : 0;
        let nr = r, nc = c;
        while (true) {
            const nnr = nr + dr, nnc = nc + dc;
            if (nnr < 0 || nnr >= 4 || nnc < 0 || nnc >= 4 || g[nnr][nnc]) break;
            nr = nnr;
            nc = nnc;
        }
        return {nr, nc};
    }

    _nextCell(r, c, dir) {
        const dr = dir === 'down' ? 1 : dir === 'up' ? -1 : 0;
        const dc = dir === 'right' ? 1 : dir === 'left' ? -1 : 0;
        return {nr: r + dr, nc: c + dc};
    }

    _isGameOver() {
        const g = this.getGrid();
        for (let r = 0; r < 4; r++)
            for (let c = 0; c < 4; c++) {
                if (!g[r][c]) return false;
                if (c < 3 && g[r][c].value === g[r][c+1]?.value) return false;
                if (r < 3 && g[r][c].value === g[r+1]?.[c]?.value) return false;
            }
        return true;
    }

    // ‚îÄ‚îÄ‚îÄ RENDERING ‚îÄ‚îÄ‚îÄ
    draw(time) {
        const ctx = this.ctx;
        const S = this.S;
        ctx.clearRect(0, 0, S, S);

        // Board bg
        ctx.fillStyle = '#0e0e16';
        ctx.beginPath();
        ctx.roundRect(0, 0, S, S, 14);
        ctx.fill();

        // Empty cells
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                const p = this.cellPos(r, c);
                ctx.fillStyle = '#1a1a24';
                ctx.beginPath();
                ctx.roundRect(p.x, p.y, this.ts, this.ts, 9);
                ctx.fill();
            }
        }

        // Animate progress
        let allDone = true;
        for (const t of this.tiles) {
            // Slide animation
            if (t.animProgress < 1) {
                t.animProgress = Math.min(1, t.animProgress + 0.12);
                allDone = false;
            }
            // Spawn animation
            if (t.scale < 1) {
                t.scale = Math.min(1, t.scale + 0.1);
                allDone = false;
            }
            // Merge scale
            if (t.mergeScale > 1) {
                t.mergeScale = Math.max(1, t.mergeScale - 0.025);
                allDone = false;
            }
        }

        // Sort: draw lower values first so merged tiles render on top
        const sorted = [...this.tiles].sort((a, b) => a.value - b.value);

        for (const t of sorted) {
            const eased = easeOutCubic(t.animProgress);
            const fromPos = this.cellPos(t.fromRow, t.fromCol);
            const toPos = this.cellPos(t.row, t.col);

            const x = fromPos.x + (toPos.x - fromPos.x) * eased;
            const y = fromPos.y + (toPos.y - fromPos.y) * eased;
            const scale = t.scale * t.mergeScale;

            const style = ts(t.value);

            ctx.save();
            const cx = x + this.ts / 2;
            const cy = y + this.ts / 2;
            ctx.translate(cx, cy);
            ctx.scale(scale, scale);
            ctx.translate(-cx, -cy);

            // Glow for high values
            if (t.value >= 128) {
                ctx.shadowColor = style.bg;
                ctx.shadowBlur = 18;
            }

            ctx.fillStyle = style.bg;
            ctx.beginPath();
            ctx.roundRect(x, y, this.ts, this.ts, 9);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Text
            const fontSize = this.ts * .36 * style.fs;
            ctx.fillStyle = style.fg;
            ctx.font = `800 ${fontSize}px 'JetBrains Mono',monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(t.value, cx, cy + 1);

            ctx.restore();
        }

        // Particles
        this.particles = this.particles.filter(p => {
            p.y += p.vy;
            p.vy *= .97;
            p.life--;
            p.opacity = p.life / 50;
            if (p.life <= 0) return false;
            ctx.save();
            ctx.globalAlpha = p.opacity;
            ctx.fillStyle = '#f7b731';
            ctx.font = `700 16px 'JetBrains Mono',monospace`;
            ctx.textAlign = 'center';
            ctx.fillText(p.text, p.x, p.y);
            ctx.restore();
            return true;
        });

        // If animations just finished
        if (this.animating && allDone) {
            return this.finishMove();
        }

        return null;
    }
}

function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GAME MANAGER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let mode = 'solo';
let boards = [];
let gameOver = false;
let ws = null;
let rafId = null;
let onlinePlayerId = null;

function startGame(m) {
    mode = m;

    if (mode === 'online') {
        showOnlineModal();
        return;
    }

    document.getElementById('menuScreen').classList.add('hidden');
    const gs = document.getElementById('gameScreen');
    gs.classList.add('active');

    buildArena();

    if (mode === 'local') {
        showCountdown(() => {
            for (const b of boards) b.init();
            startLoop();
        });
    } else {
        for (const b of boards) b.init();
        startLoop();
    }
}

function buildArena() {
    const arena = document.getElementById('arena');
    arena.innerHTML = '';
    boards.forEach(b => b.destroy?.());
    boards = [];
    gameOver = false;
    document.getElementById('resultBanner').className = 'result-banner';

    const players = mode === 'solo' ? [
        {name: 'Solo', cls: 'p1', keys: 'Fl√®ches / WASD'}
    ] : [
        {name: 'Joueur 1', cls: 'p1', keys: null},
        {name: 'Joueur 2', cls: 'p2', keys: null}
    ];

    const keyHints = mode === 'local' ? [
        '<kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>',
        '<kbd>‚Üë</kbd><kbd>‚Üì</kbd><kbd>‚Üê</kbd><kbd>‚Üí</kbd>'
    ] : ['<kbd>‚Üë</kbd><kbd>‚Üì</kbd><kbd>‚Üê</kbd><kbd>‚Üí</kbd> / <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>'];

    players.forEach((p, i) => {
        const zone = document.createElement('div');
        zone.className = 'player-zone';
        zone.id = `zone-${i}`;
        zone.innerHTML = `
            <div class="player-header">
                <div class="player-name ${p.cls}">${p.name}</div>
                <div class="player-score" id="score-${i}">0</div>
            </div>
            <div class="game-wrapper" id="wrapper-${i}">
                <canvas id="canvas-${i}"></canvas>
                <div class="overlay" id="overlay-${i}"></div>
            </div>
            <div class="player-controls">${keyHints[i] || ''}</div>
        `;
        arena.appendChild(zone);

        const canvas = document.getElementById(`canvas-${i}`);
        const scoreEl = document.getElementById(`score-${i}`);
        const board = new GameBoard(canvas, scoreEl);
        boards.push(board);
    });

    setupInput();
}

function setupInput() {
    // Remove old listener
    if (window._gameKeyHandler) document.removeEventListener('keydown', window._gameKeyHandler);

    const dirMap = {ArrowUp:'up',ArrowDown:'down',ArrowLeft:'left',ArrowRight:'right',
                    w:'up',s:'down',a:'left',d:'right',
                    W:'up',S:'down',A:'left',D:'right'};

    window._gameKeyHandler = (e) => {
        if (gameOver) return;
        const dir = dirMap[e.key];
        if (!dir) {
            if (e.key === 'r' || e.key === 'R') restartMatch();
            return;
        }
        e.preventDefault();

        if (mode === 'solo') {
            boards[0]?.move(dir);
        } else if (mode === 'local') {
            // Player 1: WASD
            if (['w','a','s','d','W','A','S','D'].includes(e.key)) {
                boards[0]?.move(dir);
            }
            // Player 2: Arrows
            if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
                boards[1]?.move(dir);
            }
        } else if (mode === 'online') {
            sendOnlineMove(dir);
        }
    };

    document.addEventListener('keydown', window._gameKeyHandler);

    // Touch/swipe for solo & P1 on mobile
    boards.forEach((board, i) => {
        let sx, sy;
        board.canvas.addEventListener('touchstart', e => {
            sx = e.touches[0].clientX;
            sy = e.touches[0].clientY;
        }, {passive:true});
        board.canvas.addEventListener('touchend', e => {
            if (gameOver) return;
            const dx = e.changedTouches[0].clientX - sx;
            const dy = e.changedTouches[0].clientY - sy;
            if (Math.max(Math.abs(dx), Math.abs(dy)) < 30) return;
            const dir = Math.abs(dx) > Math.abs(dy)
                ? (dx > 0 ? 'right' : 'left')
                : (dy > 0 ? 'down' : 'up');

            if (mode === 'online') sendOnlineMove(dir);
            else board.move(dir);
        }, {passive:true});
    });
}

function startLoop() {
    if (rafId) cancelAnimationFrame(rafId);
    const tick = (time) => {
        for (let i = 0; i < boards.length; i++) {
            const result = boards[i].draw(time);
            if (result && !gameOver) handleResult(i, result);
        }
        rafId = requestAnimationFrame(tick);
    };
    rafId = requestAnimationFrame(tick);
}

function handleResult(playerIndex, result) {
    if (mode === 'solo') {
        if (result === 'win') {
            showSoloBanner('win', boards[0].score);
        } else if (result === 'lose') {
            showSoloBanner('lose', boards[0].score);
        }
    } else {
        if (result === 'win') {
            // This player reached 2048!
            endMatch(playerIndex);
        } else if (result === 'lose') {
            // Check if both lost
            const otherIdx = playerIndex === 0 ? 1 : 0;
            if (boards[otherIdx].lost) {
                // Both lost, higher score wins
                if (boards[0].score > boards[1].score) endMatch(0);
                else if (boards[1].score > boards[0].score) endMatch(1);
                else endMatch(-1); // tie
            }
            // Otherwise the other player keeps going
        }
    }
}

function showSoloBanner(type, score) {
    gameOver = true;
    const banner = document.getElementById('resultBanner');
    const text = document.getElementById('resultText');
    if (type === 'win') {
        banner.className = 'result-banner active solo-win';
        text.textContent = `üèÜ Victoire ! Score: ${score}`;
        boards[0].keepPlaying = true;
        boards[0].won = true;
    } else {
        banner.className = 'result-banner active solo-over';
        text.textContent = `Game Over ‚Äî Score: ${score}`;
    }
}

function endMatch(winnerIdx) {
    gameOver = true;
    const banner = document.getElementById('resultBanner');
    const text = document.getElementById('resultText');

    if (winnerIdx === -1) {
        banner.className = 'result-banner active solo-over';
        text.textContent = `√âgalit√© ! ${boards[0].score} - ${boards[1].score}`;
    } else {
        banner.className = `result-banner active ${winnerIdx === 0 ? 'p1' : 'p2'}-wins`;
        text.textContent = `üèÜ Joueur ${winnerIdx + 1} gagne ! (${boards[winnerIdx].score} pts)`;
        document.getElementById(`wrapper-${winnerIdx}`).classList.add('winner');
        document.getElementById(`wrapper-${winnerIdx === 0 ? 1 : 0}`).classList.add('loser');
    }
}

function restartMatch() {
    gameOver = false;
    document.getElementById('resultBanner').className = 'result-banner';
    document.querySelectorAll('.game-wrapper').forEach(w => {
        w.classList.remove('winner', 'loser');
    });

    if (mode === 'local') {
        showCountdown(() => {
            for (const b of boards) b.init();
        });
    } else {
        for (const b of boards) b.init();
    }
}

function backToMenu() {
    if (rafId) cancelAnimationFrame(rafId);
    boards.forEach(b => b.destroy?.());
    boards = [];
    if (ws) { ws.close(); ws = null; }
    document.getElementById('gameScreen').classList.remove('active');
    document.getElementById('menuScreen').classList.remove('hidden');
}

// ‚îÄ‚îÄ‚îÄ COUNTDOWN ‚îÄ‚îÄ‚îÄ
function showCountdown(callback) {
    const el = document.getElementById('countdown');
    const num = document.getElementById('countdownNum');
    el.classList.remove('hidden');
    let count = 3;
    num.textContent = count;
    const iv = setInterval(() => {
        count--;
        if (count > 0) {
            num.textContent = count;
        } else if (count === 0) {
            num.textContent = 'GO!';
        } else {
            clearInterval(iv);
            el.classList.add('hidden');
            callback();
        }
    }, 700);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ONLINE MULTIPLAYER (WebSocket)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function showOnlineModal() {
    document.getElementById('onlineModal').classList.remove('hidden');
    document.getElementById('wsError').textContent = '';
    document.getElementById('wsStatus').textContent = 'Pr√™t ‚Äî cr√©e ou rejoins une room';
}

function closeOnlineModal() {
    document.getElementById('onlineModal').classList.add('hidden');
    if (ws) { ws.close(); ws = null; }
}

function connectWS(callback) {
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ö° CHANGE THIS to your Railway/Render/Fly.io URL in prod
    const PROD_WS_URL = '2048-royale-production-cf79.up.railway.app';  // ex: 'wss://2048-royale.up.railway.app/ws'
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const isLocal = ['localhost','127.0.0.1'].includes(window.location.hostname);
    const url = (!isLocal && PROD_WS_URL)
        ? PROD_WS_URL
        : `ws://${window.location.hostname || 'localhost'}:8080/ws`;
    document.getElementById('wsStatus').textContent = 'Connexion...';
    document.getElementById('wsError').textContent = '';

    ws = new WebSocket(url);
    ws.onopen = () => {
        document.getElementById('wsStatus').textContent = 'Connect√© ‚úì';
        callback();
    };
    ws.onerror = () => {
        document.getElementById('wsError').textContent = 'Impossible de se connecter au serveur. Lance le serveur Go !';
    };
    ws.onclose = () => {
        if (!gameOver) document.getElementById('wsStatus').textContent = 'D√©connect√©';
    };
    ws.onmessage = (e) => {
        const msg = JSON.parse(e.data);
        handleWSMessage(msg);
    };
}

function createRoom() {
    connectWS(() => {
        ws.send(JSON.stringify({type: 'create'}));
    });
}

function joinRoom() {
    const code = document.getElementById('roomInput').value.trim().toUpperCase();
    if (!code) {
        document.getElementById('wsError').textContent = 'Entre un code room';
        return;
    }
    connectWS(() => {
        ws.send(JSON.stringify({type: 'join', room: code}));
    });
}

function sendOnlineMove(dir) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        // Apply locally
        const moved = boards[0]?.move(dir);
        // Send state to server so opponent sees our grid
        if (moved) {
            // Wait for animation to finish then send state
            setTimeout(() => {
                const grid = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
                for (const t of boards[0].tiles) {
                    grid[t.row][t.col] = t.value;
                }
                ws.send(JSON.stringify({
                    type: 'state_update',
                    grid: grid,
                    score: boards[0].score
                }));
                // Check if we won
                for (const t of boards[0].tiles) {
                    if (t.value === 2048 && !boards[0].keepPlaying) {
                        ws.send(JSON.stringify({type: 'game_won'}));
                        break;
                    }
                }
            }, 200);
        }
    }
}

function handleWSMessage(msg) {
    switch (msg.type) {
        case 'room_created':
            document.getElementById('wsStatus').textContent = `Room: ${msg.room} ‚Äî En attente d'un adversaire...`;
            document.getElementById('roomInput').value = msg.room;
            onlinePlayerId = msg.player_id;
            break;

        case 'room_joined':
            onlinePlayerId = msg.player_id;
            document.getElementById('wsStatus').textContent = `Room: ${msg.room} ‚Äî Connect√© !`;
            break;

        case 'game_start':
            document.getElementById('onlineModal').classList.add('hidden');
            mode = 'online';
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('active');
            buildArena();
            // Label players
            const p1Name = document.querySelector('#zone-0 .player-name');
            const p2Name = document.querySelector('#zone-1 .player-name');
            if (p1Name) p1Name.textContent = 'Toi';
            if (p2Name) p2Name.textContent = 'Adversaire';
            showCountdown(() => {
                for (const b of boards) b.init();
                startLoop();
            });
            break;

        case 'opponent_state':
            // Update opponent's board display
            if (boards[1] && msg.grid) {
                // Rebuild opponent tiles from grid
                boards[1].tiles = [];
                for (let r = 0; r < 4; r++)
                    for (let c = 0; c < 4; c++)
                        if (msg.grid[r][c] > 0)
                            boards[1].tiles.push(new Tile(r, c, msg.grid[r][c]));
                boards[1].tiles.forEach(t => { t.scale = 1; t.animProgress = 1; });
                boards[1].score = msg.score || 0;
                boards[1].updateScore();
            }
            break;

        case 'game_over':
            if (msg.winner === onlinePlayerId) {
                endMatch(0);
            } else {
                endMatch(1);
            }
            break;

        case 'error':
            document.getElementById('wsError').textContent = msg.message;
            break;
    }
}

</script>
</body>
</html>
